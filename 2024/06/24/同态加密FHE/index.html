<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>同态加密FHE | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="《An Introduction to Fully Homomorphic Encryption》 by Nigel P. Smart1.Introduction1.1 What is FHE?原则上，FHE允许对加密数据进行任意计算。对加密数据进行计算意味着，如果用户有一个函数f并想要得到 的结果，可以通过对这些输入的加密形式 c1,c2,…,cn进行计算，得到一个解密后的结果就是 在一些加密系">
<meta property="og:type" content="article">
<meta property="og:title" content="同态加密FHE">
<meta property="og:url" content="http://example.com/2024/06/24/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86FHE/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="《An Introduction to Fully Homomorphic Encryption》 by Nigel P. Smart1.Introduction1.1 What is FHE?原则上，FHE允许对加密数据进行任意计算。对加密数据进行计算意味着，如果用户有一个函数f并想要得到 的结果，可以通过对这些输入的加密形式 c1,c2,…,cn进行计算，得到一个解密后的结果就是 在一些加密系">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624170020423.png">
<meta property="og:image" content="c:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624170040058.png">
<meta property="og:image" content="c:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624173840861.png">
<meta property="og:image" content="c:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624180448856.png">
<meta property="article:published_time" content="2024-06-24T08:36:10.000Z">
<meta property="article:modified_time" content="2024-06-24T11:39:35.819Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="CRYPTO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624170020423.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-同态加密FHE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/24/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86FHE/" class="article-date">
  <time class="dt-published" datetime="2024-06-24T08:36:10.000Z" itemprop="datePublished">2024-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      同态加密FHE
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="《An-Introduction-to-Fully-Homomorphic-Encryption》-by-Nigel-P-Smart"><a href="#《An-Introduction-to-Fully-Homomorphic-Encryption》-by-Nigel-P-Smart" class="headerlink" title="《An Introduction to Fully Homomorphic Encryption》 by Nigel P. Smart"></a>《An Introduction to Fully Homomorphic Encryption》 by Nigel P. Smart</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><h3 id="1-1-What-is-FHE"><a href="#1-1-What-is-FHE" class="headerlink" title="1.1 What is FHE?"></a>1.1 What is FHE?</h3><p>原则上，FHE允许对加密数据进行任意计算。对加密数据进行计算意味着，如果用户有一个函数f并想要得到 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624170020423.png"
                      alt="image-20240624170020423"
                >的结果，可以通过对这些输入的加密形式 c1,c2,…,cn进行计算，得到一个解密后的结果就是<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624170040058.png"
                      alt="image-20240624170040058"
                ></p>
<p>在一些加密系统中，输入消息（明文）存在于某种代数结构中，通常是群或环。</p>
<h5 id="群（Group）"><a href="#群（Group）" class="headerlink" title="群（Group）"></a>群（Group）</h5><p>群是一个基本的代数结构，由一组元素和一个二元运算（通常称为乘法或加法）构成，满足以下四个性质：</p>
<ol>
<li><strong>闭合性（Closure）</strong>：<ul>
<li>对于群中的任意两个元素 a 和 b，它们的运算结果 a⋅b也在群中。</li>
<li>例如，对于整数加法，两个整数的和仍然是整数。</li>
</ul>
</li>
<li><strong>结合律（Associativity）</strong>：<ul>
<li>对于群中的任意三个元素 a,b,c有 (a⋅b)⋅c&#x3D;a⋅(b⋅c)。</li>
<li>例如，对于整数加法，有 (a+b)+c&#x3D;a+(b+c)。</li>
</ul>
</li>
<li><strong>单位元（Identity Element）</strong>：<ul>
<li>存在一个单位元 e，对于群中的任意元素 aaa，有 a⋅e&#x3D;e⋅a&#x3D;a</li>
<li>例如，对于整数加法，单位元是 0，因为 a+0&#x3D;0+a&#x3D;a。</li>
</ul>
</li>
<li><strong>逆元（Inverse Element）</strong>：<ul>
<li>对于群中的每个元素 a，存在一个逆元 a^{-1}，使得 a⋅a^{-1} &#x3D;a^{-1}⋅a&#x3D;e。</li>
<li>例如，对于整数加法，a的逆元是 −a,因为 a+(−a)&#x3D;a+(-a)&#x3D;0。</li>
<li>在群论中，单位元 e 不是随机的，而是固定的，且对于群中的所有元素都是相同的。对于不同的群，单位元 e 的具体值可能不同，但在同一个群中，它是唯一且固定的。</li>
</ul>
</li>
</ol>
<h5 id="环（Ring）"><a href="#环（Ring）" class="headerlink" title="环（Ring）"></a>环（Ring）</h5><p>环是一个更复杂的代数结构，由一组元素和两个二元运算（通常称为加法和乘法）构成，满足以下性质：</p>
<ol>
<li><strong>加法构成一个交换群（Abelian Group）</strong>：<ul>
<li>环中的加法运算满足交换律（commutative）、结合律（associative）、单位元（identity element）和逆元（inverse element）。</li>
<li>例如，整数加法构成一个交换群。</li>
</ul>
</li>
<li><strong>乘法的闭合性（Closure under Multiplication）</strong>：<ul>
<li>对于环中的任意两个元素 a 和 b，它们的乘积 a⋅b也在环中。</li>
<li>例如，两个整数的乘积仍然是整数。</li>
</ul>
</li>
<li><strong>乘法的结合律（Associativity under Multiplication）</strong>：<ul>
<li>对于环中的任意三个元素 a,b,cm有 (a⋅b)⋅c&#x3D;a⋅(b⋅c)。</li>
<li>例如，整数乘法满足结合律。</li>
</ul>
</li>
<li><strong>乘法对加法的分配律（Distributive Laws）</strong>：<ul>
<li>环中的乘法对加法满足左分配律和右分配律，即 a⋅(b+c)&#x3D;a⋅b+a⋅c和 (a+b)⋅c&#x3D;a⋅c+b⋅c。</li>
<li>例如，整数乘法对加法满足分配律。</li>
</ul>
</li>
</ol>
<p>在这种情况下，密文通常也存在于某个相关的结构中，这个结构可能与明文的结构相同。在较旧的同态加密方案中，函数 f 通常仅限于与明文结构相关的代数运算。例如，考虑ElGamal加密。如果明文空间是一个群 G，那么密文空间是群G×G的乘积，并且f仅限于群G上的运算。实际上，2009年之前的大多数方案都适合这种结构。我们可以将完全同态加密的目标表示为将函数f扩展为任何函数。如果方案相对于一个功能完备的操作集合是同态的，并且可以从该集合中迭代操作，那么该目标就可以实现。</p>
<p>虽然从理论上讲，加密方案总是要求在安全参数的多项式时间内运行，但在获得第一个FHE方案时，实用效率并不是首要考虑的。导致这些方案缺乏效率的一个原因是它们使用一个由单个位组成的明文空间，并且相对于模2的加法和乘法是同态的。虽然可以从这些基本操作中构建任何复杂度的函数，但这可能需要大量的此类操作。</p>
<p>为了朝着更好的效率迈进，一些最近的FHE方案变体以不同方式限制了函数f，我们将在后面探讨这些方案。</p>
<p>虽然从理论上讲，FHE的观点只是最大化 f 的选择，但从实际角度来看，保持这种选择仅在必要的范围内也是很重要的，并且可能更喜欢一个比二进制案例更丰富的明文和密文空间结构。</p>
<h3 id="1-2-Relations-of-FHE-Functional-Encryption-and-Program-Obfuscation"><a href="#1-2-Relations-of-FHE-Functional-Encryption-and-Program-Obfuscation" class="headerlink" title="1.2 Relations of FHE: Functional Encryption and Program Obfuscation"></a>1.2 <strong>Relations of FHE: Functional Encryption and Program Obfuscation</strong></h3><p>完全同态加密（FHE）的基本思想是能够对加密数据应用函数。还有其他两种与函数相关的密码学概念：功能加密和模糊化。令人感兴趣的是，模糊化、功能加密和完全同态加密似乎有某种联系，正如以前所认识到的那样。</p>
<p>功能加密（FE）本质上与基于身份的加密和基于属性的加密类似。</p>
<h5 id="1-功能加密（Functional-Encryption-FE）"><a href="#1-功能加密（Functional-Encryption-FE）" class="headerlink" title="1. 功能加密（Functional Encryption, FE）"></a>1. 功能加密（Functional Encryption, FE）</h5><p>功能加密是一种允许解密方在不知道明文的情况下，直接从密文中得到某个函数应用于明文的结果的加密方式。其本质是<strong>实现某种受控的计算</strong>，只有具有特定权限的用户才能计算出相应的结果。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li>加密阶段：数据拥有者用公钥对数据进行加密，生成密文。</li>
<li>密钥颁发：由一个中心实体（如密钥生成中心）使用主密钥生成与特定函数f相关的密钥。</li>
<li>解密阶段：持有特定函数密钥的用户可以解密得到 f(明文)的结果，而无法知道明文的其他信息。</li>
</ul>
<p><strong>例子：隐私保护的医疗数据分析</strong></p>
<ul>
<li><strong>场景</strong>：一个医院希望将患者的医疗数据进行分析，以预测某种疾病的风险，但又不希望分析人员直接看到患者的具体数据。</li>
<li>过程：<ul>
<li>医院使用公钥 pk对患者的医疗数据进行加密，生成密文 c。</li>
<li>分析机构需要进行疾病风险预测，医院使用主密钥生成与风险预测函数 f 相关的功能密钥 skf。</li>
<li>分析人员使用功能密钥 skf对加密的医疗数据 cc进行计算，得到 f(医疗数据) 的结果，比如某个患者患某种疾病的概率。</li>
<li>分析人员只能得到计算结果，而无法看到具体的患者数据，从而保护了患者的隐私。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-基于身份的加密（Identity-Based-Encryption-IBE）"><a href="#2-基于身份的加密（Identity-Based-Encryption-IBE）" class="headerlink" title="2. 基于身份的加密（Identity-Based Encryption, IBE）"></a>2. 基于身份的加密（Identity-Based Encryption, IBE）</h5><p>基于身份的加密是一种公钥加密方案，在该方案中，公钥是由用户的身份信息（如电子邮件地址）直接生成的。IBE旨在简化公钥管理，特别是在需要大规模分发公钥的系统中。</p>
<ul>
<li><strong>工作原理</strong>：<ul>
<li>公钥生成：用户的公钥可以直接由其身份信息（如姓名、电子邮件地址等）生成。</li>
<li>密钥生成：一个可信第三方（通常称为私钥生成中心，PKG）使用其主私钥生成用户的私钥，并将其分发给用户。</li>
<li>加密阶段：发送者使用接收者的身份信息生成公钥，并对信息进行加密。</li>
<li>解密阶段：接收者使用从PKG处获得的私钥解密信息。</li>
</ul>
</li>
</ul>
<h5 id="3-基于属性的加密（Attribute-Based-Encryption-ABE）"><a href="#3-基于属性的加密（Attribute-Based-Encryption-ABE）" class="headerlink" title="3. 基于属性的加密（Attribute-Based Encryption, ABE）"></a>3. 基于属性的加密（Attribute-Based Encryption, ABE）</h5><p>基于属性的加密是一种更灵活的加密方式，允许加密和解密操作<strong>基于用户的属性集合</strong>。ABE主要有两种变体：基于密文策略的ABE（CP-ABE）和基于密钥策略的ABE（KP-ABE）。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li><p>CP-ABE</p>
<p>（Ciphertext-Policy ABE）：数据加密时，密文中包含访问策略，只有符合策略的用户才能解密。</p>
<ul>
<li>加密阶段：数据拥有者定义访问策略，并用策略加密数据。</li>
<li>密钥颁发：一个可信第三方根据用户的属性集合生成私钥。</li>
<li>解密阶段：只有属性集合满足密文中策略的用户才能解密数据。</li>
</ul>
</li>
<li><p>KP-ABE</p>
<p>（Key-Policy ABE）：每个用户的私钥包含访问策略，密文中包含属性集合，只有符合策略的私钥才能解密。</p>
<ul>
<li>加密阶段：数据拥有者用属性集合加密数据。</li>
<li>密钥颁发：一个可信第三方根据用户的访问策略生成私钥。</li>
<li>解密阶段：只有策略匹配密文中属性集合的用户才能解密数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Boneh、Sahai和Waters简洁地解释了这三种概念之间的关系，并讨论了FHE。实际上，<strong>FHE和FE确实有一些重叠，研究表明，功能加密可以通过一些调整来实现FHE</strong>。</p>
<p>功能加密允许使用主密钥颁发一个与函数f相关的密钥。给定一个密文，这个密钥允许用户了解f应用于明文的值，而不会泄露其他信息。对加密数据计算函数将这两种概念联系起来。一个显著的区别是函数的应用方式。FE通过主密钥持有者控制可以应用于数据的函数，而<strong>FHE允许任何拥有评估密钥的人运行函数</strong>，<strong>但只有秘密密钥的持有者可以解密结果</strong>。运行函数的用户只能得到密文。</p>
<p>模糊化最初的设计理念类似于黑箱计算，其中一个人可以知道输入和输出，但不知道中间过程。通过模糊化（Program Obfuscation），可以将密钥放在程序中运行，而不会暴露密钥的知识。这样可以生成一个包含公钥和私钥的模糊化程序，通过先应用解密算法，再应用所需函数，最后加密结果。这可以作为FHE中同态操作的替代。</p>
<p>尽管从模糊化方案和传统加密方案生成FHE方案的能力似乎很有前景，但实际上是否比直接FHE更有优势仍不明确。还需要考虑在发布程序中隐藏秘密密钥的安全约束和影响。</p>
<h3 id="1-3-Need-for-Systematization"><a href="#1-3-Need-for-Systematization" class="headerlink" title="1.3 Need for Systematization"></a>1.3 <strong>Need for Systematization</strong></h3><p>完全同态加密（FHE）的处理可能显得非常混乱。有时，两个定义看起来好像在说同一件事——例如，能够<strong>评估一个</strong>任意电路和能够<strong>连续评估任意多个</strong>电路看起来似乎是一样的。然而，这实际上不是一回事，正如将在注释5中解释的那样。</p>
<p>为了帮助理解这个区别，考虑云计算的例子：FHE通常被宣传为解决方案。然而，如果我们只能评估一个任意大小的电路，那么我们不能使用中间结果进行后续计算；所有的计算必须从原始密文开始重新计算。这满足了FHE的通常定义（定义9），但并不直观，也不是一个最佳解决方案。在这种情况下，我们需要能够连续评估任意多个电路。</p>
<p>这突显了该领域的另一个问题：在某些情况下，定义并没有表达出人们直观上假设的内容。在其他情况下，某一概念在不同论文中的定义不同。例如，紧凑性这个属性，直观上说密文大小不应该通过同态操作而增长。Gentry在他最初的工作中通过一个特性来定义它，而在随后的工作中使用了另一个特性。看出这两个定义是等价的并不像想象的那么简单，实际上需要一个额外的假设。</p>
<p>有时，属性没有得到适当的定义，有时则在同一篇论文中未提及就被使用了。图1展示了这些定义的复杂程度。从定义和属性（图中的白色矩形）开始，我们可以给出不同类型同态方案的分类（阴影的圆角矩形）。此外，这些分类可以与跳跃正确性结合，产生另一组同态方案（更深色的椭圆形）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624173840861.png"
                      alt="image-20240624173840861"
                ></p>
<h5 id="注释5：关于连续电路评估的区别"><a href="#注释5：关于连续电路评估的区别" class="headerlink" title="注释5：关于连续电路评估的区别"></a>注释5：关于连续电路评估的区别</h5><p>在云计算的例子中，FHE通常被视为解决方案。然而，如果我们只能评估一个任意大小的电路，那么我们不能使用中间结果进行后续计算（中间结果的不可用性）；所有的计算必须从原始密文开始重新计算。这满足了通常对FHE的定义（定义9），但不符合直觉，也不是一个最佳解决方案。在这种情况下，我们需要能够连续评估任意多个电路。</p>
<h3 id="1-4-Our-Contribution"><a href="#1-4-Our-Contribution" class="headerlink" title="1.4 Our Contribution"></a>1.4 <strong>Our Contribution</strong></h3><h2 id="2-Applications-of-FHE"><a href="#2-Applications-of-FHE" class="headerlink" title="2 Applications of FHE"></a><strong>2 Applications of FHE</strong></h2><h3 id="2-1-Practical-Applications-of-FHE"><a href="#2-1-Practical-Applications-of-FHE" class="headerlink" title="2.1 Practical Applications of FHE"></a><strong>2.1 Practical Applications of FHE</strong></h3><h4 id="2-1-1-Consumer-Privacy-in-Advertising"><a href="#2-1-1-Consumer-Privacy-in-Advertising" class="headerlink" title="2.1.1 Consumer Privacy in Advertising"></a><strong>2.1.1 Consumer Privacy in Advertising</strong></h4><h4 id="2-1-2-Medical-Applications"><a href="#2-1-2-Medical-Applications" class="headerlink" title="2.1.2 Medical Applications"></a><strong>2.1.2 Medical Applications</strong></h4><h4 id="2-1-3-Data-Mining"><a href="#2-1-3-Data-Mining" class="headerlink" title="2.1.3 Data Mining"></a><strong>2.1.3 Data Mining</strong></h4><h4 id="2-1-4-Financial-Privacy"><a href="#2-1-4-Financial-Privacy" class="headerlink" title="2.1.4 Financial Privacy"></a><strong>2.1.4 Financial Privacy</strong></h4><h4 id="2-1-5-Forensic-Image-Recognition"><a href="#2-1-5-Forensic-Image-Recognition" class="headerlink" title="2.1.5 Forensic Image Recognition"></a><strong>2.1.5 Forensic Image Recognition</strong></h4><h3 id="2-2-Homomorphic-Encryption-Schemes-as-Building-Blocks"><a href="#2-2-Homomorphic-Encryption-Schemes-as-Building-Blocks" class="headerlink" title="2.2 Homomorphic Encryption Schemes as Building Blocks"></a><strong>2.2 Homomorphic Encryption Schemes as Building Blocks</strong></h3><h4 id="2-2-1-Zero-Knowledge-Proofs"><a href="#2-2-1-Zero-Knowledge-Proofs" class="headerlink" title="2.2.1 Zero Knowledge Proofs"></a><strong>2.2.1 Zero Knowledge Proofs</strong></h4><p>Gentry 在他的论文 [28] 中展示了同态加密可以用于构建小尺寸的非交互式零知识（NIZK）证明。用户希望证明其掌握了一组满足布尔电路 C 的位分配 π1,…,πt。NIZK 证明包括生成一个公钥，加密这些 πi 并对这些加密后的值同态地评估电路 C。一个标准的 NIZK 证明附带了以下内容：证明每个密文加密的值要么是 0 要么是 1，并且评估的输出加密的值是 1。</p>
<h5 id="非交互式零知识（NIZK）"><a href="#非交互式零知识（NIZK）" class="headerlink" title="非交互式零知识（NIZK）"></a>非交互式零知识（NIZK）</h5><p>非交互式零知识证明（Non-Interactive Zero-Knowledge Proof, NIZK）是一种密码学协议，允许证明者向验证者证明某个陈述是真实的，而无需进行多轮的交互过程。在NIZK中，证明者只需发送一个单一的证明，验证者通过该证明即可验证陈述的真实性。</p>
<ol>
<li><strong>零知识性</strong>：<ul>
<li>零知识性意味着验证者除了知道陈述是真实的之外，无法从证明中获取任何其他信息。</li>
</ul>
</li>
<li><strong>非交互性</strong>：<ul>
<li>非交互性指的是证明过程不需要证明者和验证者之间的多轮交互。证明者可以一次性生成并发送证明，验证者在收到证明后即可完成验证。</li>
</ul>
</li>
<li><strong>完备性</strong>：<ul>
<li>如果陈述是真实的，诚实的证明者总是能够生成一个使验证者接受的证明。</li>
</ul>
</li>
<li><strong>可靠性</strong>：<ul>
<li>如果陈述是虚假的，即使是欺骗性的证明者也无法生成一个使诚实的验证者接受的证明，除非发生极小概率的错误。</li>
</ul>
</li>
</ol>
<h4 id="2-2-2-Delegation-of-Computation"><a href="#2-2-2-Delegation-of-Computation" class="headerlink" title="2.2.2 Delegation of Computation"></a><strong>2.2.2 Delegation of Computation</strong></h4><p>计算的委托是云计算的主要用例之一。云计算的基本概念是将计算和数据存储从本地计算机或服务器转移到由第三方管理的大型远程服务器上。这为企业和个人提供了显著的成本节约和可扩展性。</p>
<p>同态加密允许在云环境中安全地委托计算。通过同态加密，用户可以将数据加密后发送到云服务器，云服务器在不解密数据的情况下执行计算，并返回加密的结果。用户接收加密的结果并使用私钥进行解密，从而得到最终的计算结果。</p>
<p>这种方法的主要优点是，即使云服务器不可信，用户的数据仍然是安全的。云服务器在整个计算过程中都无法访问明文数据，从而确保数据隐私。</p>
<p>以下是一个具体的例子：</p>
<ul>
<li><p><strong>场景</strong>：一个公司希望在云上进行大规模的数据分析，但不希望云提供商访问其敏感数据。</p>
</li>
<li><p>过程</p>
<p>：</p>
<ul>
<li>公司使用公钥对数据进行加密，并将加密数据发送到云服务器。</li>
<li>云服务器在加密数据上执行同态计算，例如运行统计分析、数据挖掘算法等。</li>
<li>云服务器将计算结果加密后发送回公司。</li>
<li>公司使用私钥解密结果，获取所需的分析结果。</li>
</ul>
</li>
</ul>
<p>通过这种方式，公司的数据在整个过程中始终保持加密状态，云服务器无法访问数据的实际内容，从而保护了数据隐私。</p>
<h4 id="2-2-3-Signatures"><a href="#2-2-3-Signatures" class="headerlink" title="2.2.3 Signatures"></a><strong>2.2.3 Signatures</strong></h4><p>Craig Gentry和Shai Halevi在2011年的一篇论文中提出了基于同态加密的签名方案。该方案利用了同态加密的特性来构建数字签名。</p>
<p>在传统的数字签名方案中，签名是通过私钥对消息进行加密，验证是通过公钥进行的。而在基于同态加密的签名方案中，签名者首先生成一个公私钥对，并使用私钥对消息进行加密，然后对加密后的消息进行同态运算，以生成签名。验证者使用公钥对签名进行验证。</p>
<p>基于同态加密的签名方案有几个优点：</p>
<ol>
<li><strong>安全性</strong>：<ul>
<li>由于同态加密的特性，签名过程和验证过程都可以在加密状态下进行，确保了数据的安全性。</li>
</ul>
</li>
<li><strong>灵活性</strong>：<ul>
<li>同态加密允许对加密数据进行计算，这意味着签名可以在不解密数据的情况下进行，从而提高了系统的灵活性。</li>
</ul>
</li>
<li><strong>高效性</strong>：<ul>
<li>这种方案可以减少签名和验证过程中的计算开销，从而提高系统的效率。</li>
</ul>
</li>
</ol>
<p>基于同态加密的签名方案在实际应用中有广泛的前景。例如，在云计算环境中，用户可以在不泄露私钥的情况下生成签名，并通过同态加密来验证签名，从而保护数据的隐私和安全。</p>
<h4 id="2-2-4-Multiparty-Computation"><a href="#2-2-4-Multiparty-Computation" class="headerlink" title="2.2.4 Multiparty Computation"></a><strong>2.2.4 Multiparty Computation</strong></h4><p>多方计算（Multiparty Computation, MPC）是一种密码学技术，<strong>使得多个参与方能够在不泄露各自输入的情况下共同计算一个函数的结果。同态加密可以显著增强MPC的效率和安全性</strong>。</p>
<p>在传统的MPC协议中，每个参与方都必须不断与其他参与方交换信息，直到计算完成。利用同态加密，参与方可以加密他们的输入并将加密数据发送到一个中央服务器。中央服务器在不解密数据的情况下执行计算，并将结果发送回各参与方。参与方使用他们的私钥解密结果，得到计算的最终输出。</p>
<p>这种方法的主要优点包括：</p>
<ol>
<li><strong>隐私保护</strong>：<ul>
<li>各参与方的输入数据在整个计算过程中始终保持加密状态，从而保护了数据的隐私。</li>
</ul>
</li>
<li><strong>减少通信开销</strong>：<ul>
<li>利用同态加密，参与方只需要将加密数据发送到中央服务器，而不需要进行多轮的交互，从而减少了通信开销。</li>
</ul>
</li>
<li><strong>计算效率</strong>：<ul>
<li>中央服务器可以在加密数据上直接进行计算，提高了计算效率。</li>
</ul>
</li>
</ol>
<p>例如，在一个医疗研究项目中，不同医院希望共同分析病人的数据以研究某种疾病的风险因素，但不希望共享各自的病人数据。通过同态加密，各医院可以加密病人数据并将加密数据发送到一个中央服务器。中央服务器在不解密数据的情况下进行分析，并将加密的分析结果发送回各医院。各医院解密结果，得到研究的结论，而无需暴露病人的隐私数据。</p>
<p>总的来说，同态加密为多方计算提供了一种高效、安全的方法，使得多个参与方能够在不泄露各自输入的情况下共同计算一个函数的结果，从而在保护数据隐私的同时实现协同计算。</p>
<h3 id="2-3-Limitations-of-FHE"><a href="#2-3-Limitations-of-FHE" class="headerlink" title="2.3 Limitations of FHE"></a><strong>2.3 Limitations of FHE</strong></h3><p>完全同态加密（FHE）虽然具有强大的功能，但在实际应用中仍然存在一些限制。</p>
<p>首先，FHE的<strong>计算开销</strong>非常高。同态加密和解密操作，以及在加密数据上的同态计算，通常比传统的加密方法要慢得多。这种计算开销的增加使得FHE在处理大量数据或需要高性能计算的应用中难以使用。</p>
<p>其次，<strong>密文扩展问题</strong>也是一个重要限制。在许多FHE方案中，密文的大小随着计算的进行而增加。这意味着在长时间的计算过程中，密文会变得非常大，从而增加存储和传输的负担。</p>
<p>再者，FHE的实现复杂度较高。FHE算法的实现需要<strong>复杂的数学操作和优化技术</strong>，这使得其开发和维护成本较高。此外，<strong>现有的FHE库和工具尚未成熟</strong>，应用开发者需要具备较高的专业知识。</p>
<p>最后，虽然FHE可以在理论上保证数据的完全隐私，但在实际应用中，系统的安全性仍然依赖于具体的实现细节和假设。例如，某些FHE方案可能依赖于特定的数学难题，<strong>其安全性尚未得到充分验证</strong>。</p>
<p>综上所述，尽管FHE在隐私保护和数据安全方面具有巨大潜力，但其高计算开销、密文扩展问题、实现复杂度和安全性依赖性等限制，使得在实际应用中还需要进一步的研究和优化。</p>
<h2 id="3-Definitions"><a href="#3-Definitions" class="headerlink" title="3 Definitions"></a><strong>3 Definitions</strong></h2><p>本节概述了在FHE文献中使用的术语。我们的一些定义直接来自现有论文，而其他定义则被重新表述，因为没有令人满意的正式定义或为了将定义适应我们的正式框架；在前一种情况下，我们会给出引用。</p>
<p>我们从一个空间 P&#x3D;{0,1}开始，称之为明文空间，以及一个从明文元组到 P 的函数族 F。我们可以将这样的函数表示为其输入上的布尔电路。如果我们用 C 表示这个电路，我们用普通的函数表示法 C(m1,m2,…,mn) 来表示在元组 (m1,m2,…,mn)上评估电路。我们的第一个定义遵循 Brakerski 和 Vaikuntanathan 的工作 [16]。</p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/Y9000p/AppData/Roaming/Typora/typora-user-images/image-20240624180448856.png"
                      alt="image-20240624180448856"
                ></li>
</ul>
<p>这里，XXX 表示密文空间，它包含新生成的密文（见公式 (1)），YYY 表示评估输出空间，ZZZ 是 XXX 和 YYY 的并集。Z∗Z^*Z∗ 包含由 ZZZ 中元素组成的任意长度的元组。密钥空间分别由 Kp,KsKp, KsKp,Ks 和 KeKeKe 表示，对应于 pk,skpk, skpk,sk 和 evkevkevk。公钥包含明文空间和密文空间的描述。密钥生成算法 Gen 的输入以一元记号表示，即 1λ1^\lambda1λ。Gen 还可以从空间 auxsauxsauxs 中接受另一个可选输入 α\alphaα，这是辅助输入，将在备注 3 中阐明。最后，CCC 是允许的电路集，即方案可以评估的所有电路。</p>
<p>定义这些空间后，算法的定义域和值域如下： Gen:N×A→Kp×Ks×Ke\text{Gen} : \mathbb{N} \times A \rightarrow Kp \times Ks \times KeGen:N×A→Kp×Ks×Ke Enc:Kp×P→X\text{Enc} : Kp \times P \rightarrow XEnc:Kp×P→X Dec:Ks×Z→P\text{Dec} : Ks \times Z \rightarrow PDec:Ks×Z→P Eval:Ke×C×Z∗→Y\text{Eval} : Ke \times C \times Z^* \rightarrow YEval:Ke×C×Z∗→Y</p>
<p>其中 X∪Y&#x3D;ZX \cup Y &#x3D; ZX∪Y&#x3D;Z，AAA 是一个辅助空间。注意，一般来说，评估空间可以与密文空间不相交。</p>
<p>在整篇论文中，我们将密文空间 XXX 视为加密的结果，而评估空间 YYY 视为评估的结果。因此 ZZZ 不能包含不是加密算法或评估算法可能输出的元素。形式上， X&#x3D;{c∣Pr⁡[Enc(pk,m)&#x3D;c]&gt;0,m∈P}X &#x3D; {c \mid \Pr[\text{Enc}(pk, m) &#x3D; c] &gt; 0, m \in P }X&#x3D;{c∣Pr[Enc(pk,m)&#x3D;c]&gt;0,m∈P} 和 Y&#x3D;{z∣Pr⁡[Eval(evk,C,c1,…,cn)&#x3D;z]&gt;0,ci∈Z,且C∈C}。Y &#x3D; {z \mid \Pr[\text{Eval}(evk, C, c_1, …, c_n) &#x3D; z] &gt; 0, c_i \in Z, 且 C \in C }。Y&#x3D;{z∣Pr[Eval(evk,C,c1,…,cn)&#x3D;z]&gt;0,ci∈Z,且C∈C}。</p>
<p>特别是，评估密钥通常也是公钥的一部分。通过这种方式定义方案，具有单独的评估密钥，我们并没有禁止 pk&#x3D;evkpk &#x3D; evkpk&#x3D;evk，但断言这不是严格必要的。分开的 pkpkpk 和 evkevkevk 正在成为标准定义 [16, § 3.1]。</p>
<p>备注 1（密文解密）：Brakerski 和 Vaikuntanathan [17] 提到，运行加密算法的输出上的解密算法并不是严格必要的：“… 我们不要求密文 cic_ici 本身是可解密的，只要求它们在同态评估后变得可解密。” 他们指出，可以在解密前用空电路（本质上是计算函数 f(x)&#x3D;xf(x) &#x3D; xf(x)&#x3D;x 的电路）评估加密的密文，从而简化解密算法的允许输入。从现在开始，我们允许新鲜密文的解密，因为这似乎是更自然的方法，并适用于大多数已知的 FHE 方案。解密算法可以在密文或评估输出上操作（从密文空间和评估空间中获取值）。这种选择消除了对空电路的需求。一般来说，这种区分不是必要的，尤其是…</p>
<h3 id="3-1-Attributes"><a href="#3-1-Attributes" class="headerlink" title="3.1 Attributes"></a><strong>3.1 Attributes</strong></h3><h3 id="3-2-Classifications"><a href="#3-2-Classifications" class="headerlink" title="3.2 Classifications"></a><strong>3.2 Classifications</strong></h3><h3 id="3-3-Evaluating-in-Stages"><a href="#3-3-Evaluating-in-Stages" class="headerlink" title="3.3 Evaluating in Stages"></a><strong>3.3 Evaluating in Stages</strong></h3><h2 id="4-Implications"><a href="#4-Implications" class="headerlink" title="4 Implications"></a><strong>4 Implications</strong></h2><h3 id="4-1-Consolidating-compactness"><a href="#4-1-Consolidating-compactness" class="headerlink" title="4.1 Consolidating compactness"></a><strong>4.1 Consolidating compactness</strong></h3><h3 id="4-2-FHE-and-Hop-Results"><a href="#4-2-FHE-and-Hop-Results" class="headerlink" title="4.2 FHE and Hop Results"></a><strong>4.2 FHE and Hop Results</strong></h3><h2 id="5-Existing-schemes"><a href="#5-Existing-schemes" class="headerlink" title="5 Existing schemes"></a><strong>5 Existing schemes</strong></h2><h3 id="5-1-Bootstrapping-and-Alternatives"><a href="#5-1-Bootstrapping-and-Alternatives" class="headerlink" title="5.1 Bootstrapping and Alternatives"></a><strong>5.1 Bootstrapping and Alternatives</strong></h3><h3 id="5-2-Security-Assumptions"><a href="#5-2-Security-Assumptions" class="headerlink" title="5.2 Security Assumptions"></a><strong>5.2 Security Assumptions</strong></h3><h3 id="5-3-Implementations"><a href="#5-3-Implementations" class="headerlink" title="5.3 Implementations"></a><strong>5.3 Implementations</strong></h3><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6 Conclusion"></a><strong>6 Conclusion</strong></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/24/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86FHE/" data-id="clxygvmpl0005p4uah0vz072g" data-title="同态加密FHE" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CRYPTO/" rel="tag">CRYPTO</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/06/24/THE%20CHINESE%20BOOK%20FOR%20LARGE%20LANGUAGE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CRYPTO/" rel="tag">CRYPTO</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CRYPTO/" style="font-size: 10px;">CRYPTO</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/24/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86FHE/">同态加密FHE</a>
          </li>
        
          <li>
            <a href="/2024/06/24/THE%20CHINESE%20BOOK%20FOR%20LARGE%20LANGUAGE/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/06/23/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>